## 浅谈微前端及其简单实现

### 1 关于微前端

#### 1.1 什么是微前端 ？

常见应用模型：一个项目分为多个模块，如首页、分类页、购物车、发现、信息、订单等。应用大，打包构建慢，每改个bug就要打一次包，耗时长。且项目足够大时，人比较多，协同困难。

可以将每个模块拆分为单独的应用，将单应用放到主应用中运行。被拆分的单应用由不同团队管理。

微前端就是将不同的功能按照不同的维度拆分为多个子应用，通过主应用加载子应用。（微前端的核心在于拆，拆完再合。）

#### 1.2 为什么使用微前端 ？

- 不同团队间开发同一应用但技术栈不同

- 希望每个团队可以独立开发，独立部署

- 项目中需要旧的应用代码

可以将一个应用划分成多个子应用，将子应用打包成一个个的lib。当路径切换时加载不同的子应用。这样每个子应用都是独立存在，技术栈也没有限制，解决前端协同开发问题。

#### 1.3 如何落地微前端 ？

2018年，Single-SPA 诞生，Single-SPA 是一个用于前端微服务化的 JavaScript 前端解决方案（本身没有处理父子应用或平级应用间的样式隔离， 没有对 js 进行隔离，不同应用都处理了 window，可能会冲突），仅仅实现了路由劫持和应用加载，即根据不同路由加载不同应用。

2019年，qiankun 基于 Single-SPA 提供了开箱即用的 API（Single-SPA + sandbox + import-html-entry），做到了技术栈无关，且接入简单（像 iframe 一样简单）。

> 接入协议：要想接入应用，要求子应用必须有相关的协议，即子应用必须导出固定的方法，供父应用使用。

> 子应用可独立创建，运行时动态加载，主子应用完全解耦，与技术栈无关，靠的是协议接入（子应用必须导出 bootstrap、mount、eunmount 方法）。

为什么不是 iframe ?

如果使用 iframe， 当用户刷新页面时，子应用路由无法保存状态。

应用间如何通信？

- 基于 URL 进行数据传递，但是传递消息能力弱

- 基于 CustomEvent 实现通信

- 基于 props 主子应用间通信

- 使用全局变量、Redux进行通信

公共依赖

- CDN extrtnals （主应用加载了Vue，子应用右加载一遍Vue，主应用加载了VueRouter，子应用又加载VueRouter，可以将其抽离未公共使用）

- webpack 联邦模块

### 2 Single-SPA 实战

#### 2.1 构建子应用

#### 2.2 配置库打包

#### 2.3 主应用搭建

#### 2.4 动态设置子应用 publicPath

### 3 qiankun 实战

#### 3.1 主应用编写

#### 3.2 注册子应用

#### 3.3 子 Vue 应用

#### 3.4 子 React 应用

### 4 CSS 隔离方案

*子应用间的样式隔离*

- `Dynamic Stylesheet` 动态样式表，当应用切换时移除老应用样式，添加新应用样式（加载 A 时，引入 A 的样式，加载 B 时，移除 A 的样式，引入 B 的样式）。可以实现子应用间样式隔离，但不能实现父子应用样式隔离。

*主应用和子应用之间的样式隔离*

- `BEM(Block Element Modifier)` 约定项目前缀。在写子应用时添加专属前缀，但若不遵守约定会造成样式冲突。

- `CSS-Modules` 打包时生成不冲突的选择器名。编译时，在每个样式表后添加不冲突的随机串，使用广，主流。

- `Shadow DOM` 真正意义上的隔离。例如 video 标签，除了主显示外，还有控制音量、播放速度等的原生 dom 未展示给用户，其实是真实存在的。其作为影子，映射到了 video 标签内。qiankun 默认开启。

- `css-in-js`

### 5 JS 沙箱机制

当运行子应用时应该跑在内部沙箱环境中，应用的运行，从开始到结束，都运行在沙箱中，不会影响外部（全局）。

- 快照沙箱：在应用沙箱挂载或卸载时记录快照，在切换时依据快照恢复环境（无法支持多实例）。

- Proxy 代理沙箱，不影响全局环境。

#### 5.1 快照沙箱

- 激活时将当前 window 属性进行快照处理。

- 失活时用快照中的内容和当前 window 属性比对。

- 如果属性发生变化保存到 modifyPropsMap 中，并用快照还原 window 属性。

- 再次激活时，再次进行快照，并用上次修改的结果还原 window。

> 快照沙箱只能针对单实例应用场景，如果是多个实例同时挂载的情况则无法解决，只能通过 proxy 代理沙箱实现。

#### 5.2 Proxy 代理沙箱

>  每个应用都创建一个 proxy 来代理 window，每个应用都相对独立，不需要直接修改全局 window 属性。